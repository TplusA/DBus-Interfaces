#! /usr/bin/env python3

#
# Copyright (C) 2022, 2023  T+A elektroakustik GmbH & Co. KG
#
# This file is part of T+A-D-Bus.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#

import argparse
import xml.etree.ElementTree as ET
from pathlib import Path
import sys
import re


if sys.version_info >= (3, 9, 0):
    def _remove_prefix(s, p):
        return s.removeprefix(p)
else:
    def _remove_prefix(s, p):
        return s[len(p):] if s.startswith(p) else s


def _mk_include_guard(options):
    if options['include_guard']:
        return options['include_guard']

    if options['output_hh']:
        return options['output_hh'].name.upper().replace('.', '_')

    return 'MOCK_DBUS_' + options['FILE'].stem.upper() + '_HH'


def _write_header_top(hhfile, include_guard, mocked_header, namespace):
    template = """//
// Generated by taddybus-mockgen.
// Do not modify!
//

#ifndef {}
#define {}

#include "dbus/{}"
#include "mock_dbus_utils.hh"
#include "mock_expectation.hh"

namespace {}
{{"""
    print(template.format(include_guard, include_guard, mocked_header,
                          namespace),
          file=hhfile)


def _write_header_bottom(hhfile, include_guard):
    template = """
extern Mock *singleton;

}}

#endif /* !{} */"""
    print(template.format(include_guard), file=hhfile)


def _to_snake_case(name, divider='_'):
    return divider.join(re.findall(R'[A-Z]+$|[A-Z]*[a-z]+', name)).lower()


def _method_name(iface_type, name, is_call=False):
    return _to_snake_case(iface_type) + '_' + name + ('()' if is_call else '')


def _map_simple_type_to_ctype(typespec):
    dbus_type_to_ctype = {
        "b": "gboolean",
        "d": "gdouble",
        "i": "gint",
        "n": "gint16",
        "o": "const gchar *",
        "q": "guint16",
        "s": "const gchar *",
        "t": "guint64",
        "u": "guint",
        "v": "GVariant *",
        "x": "gint64",
        "y": "guchar",
        "as": "const gchar *const *",
    }

    ctype = dbus_type_to_ctype.get(typespec, None)
    if ctype and ctype[-1] != '*':
        return ctype + ' '
    else:
        return ctype


def _type_is_pointer(param):
    return param.attrib['type'][0] in ('s', 'o', 'v', 'a')


def _type_is_string(param):
    return param.attrib['type'] in ('s', 'o')


def _type_is_string_array(param):
    return param.attrib['type'] == 'as'


def _type_is_float(param):
    return param.attrib['type'] == 'd'


def _type_is_gvariant(param):
    t = param.attrib['type']
    return t[0] in ('v', 'a') and t != 'as'


def _map_simple_type_to_cptrtype(typespec):
    dbus_type_to_ctype = {
        "b": "gboolean *",
        "d": "gdouble *",
        "i": "gint *",
        "n": "gint16 *",
        "o": "gchar **",
        "q": "guint16 *",
        "s": "gchar **",
        "t": "guint64 *",
        "u": "guint *",
        "v": "GVariant **",
        "x": "gint64 *",
        "y": "guchar *",
        "as": "gchar ***",
    }

    ctype = dbus_type_to_ctype.get(typespec, None)
    if ctype and ctype[-1] != '*':
        return ctype + ' '
    else:
        return ctype


def _map_simple_type_to_ctortype(typespec):
    dbus_type_to_cpptype = {
        "b": "gboolean",
        "d": "gdouble",
        "i": "gint",
        "n": "gint16",
        "o": "std::string &&",
        "q": "guint16",
        "s": "std::string &&",
        "t": "guint64",
        "u": "guint",
        "v": "GVariant *",
        "x": "gint64",
        "y": "guchar",
        "as": "std::vector<std::string> &&",
    }

    ctype = dbus_type_to_cpptype.get(typespec, None)
    if ctype and ctype[-1] != '*' and ctype[-1] != '&':
        return ctype + ' '
    else:
        return ctype


def _map_simple_type_to_memtype(typespec):
    dbus_type_to_cpptype = {
        "b": "gboolean",
        "d": "gdouble",
        "i": "gint",
        "n": "gint16",
        "o": "std::string",
        "q": "guint16",
        "s": "std::string",
        "t": "guint64",
        "u": "guint",
        "v": "GVariant *",
        "x": "gint64",
        "y": "guchar",
        "as": "std::vector<std::string>",
    }

    ctype = dbus_type_to_cpptype.get(typespec, None)
    if ctype and ctype[-1] != '*' and ctype[-1] != '&':
        return ctype + ' '
    else:
        return ctype


def _map_simple_type_to_conversion(typespec):
    dbus_type_to_fn = {
        "as": "MockDBusUtils::mk_string_vector",
    }

    return dbus_type_to_fn.get(typespec, None)


def _map_simple_type_to_cpp_default_ctor(typespec):
    dbus_type_to_ctor = {
        "b": "FALSE",
        "d": "0.0",
        "i": "0",
        "n": "0",
        "o": "std::string()",
        "q": "0",
        "s": "std::string()",
        "t": "0",
        "u": "0",
        "v": "g_variant_new_string(\"dummy\")",
        "x": "0",
        "y": "0",
        "as": "std::vector<std::string>()",
    }

    return dbus_type_to_ctor.get(typespec, "{}")


def _map_simple_type_to_const_memtype(typespec):
    ctype = _map_simple_type_to_memtype(typespec)
    if ctype and typespec not in ('v', 'a'):
        ctype = 'const ' + ctype
    return ctype


def _skip_parameter(param, is_method, need_return_types):
    if is_method:
        dir = param.attrib.get('direction', 'in')

        if (need_return_types and dir == 'in') or \
                (not need_return_types and dir != 'in'):
            return True

    return False


def _mk_argument_list(params, is_method, mapping_fn, *,
                      need_return_types=False, append_to_name='',
                      need_prefixed_names=True, need_types=True,
                      use_plain_map_result=False):
    args = []

    for param in params.findall('arg'):
        if _skip_parameter(param, is_method, need_return_types):
            continue

        if need_prefixed_names:
            argname = 'out_' if need_return_types else 'arg_'
        else:
            argname = ''

        argname += param.attrib['name'] + append_to_name

        type = None
        is_array = None
        is_forced_type = False

        for anno in param.findall('annotation'):
            if anno.attrib['name'] == 'org.gtk.GDBus.C.ForceGVariant' and \
                    anno.attrib['value'] == 'arg':
                type = param.attrib['type']
                is_array = True
                is_forced_type = True
                break

        if not is_forced_type:
            type = param.attrib['type']
            is_array = type[0] == 'a'

        if need_types:
            if is_array:
                if not is_forced_type and type == 'as':
                    t = mapping_fn(type) + argname
                else:
                    t = mapping_fn('v') + argname + ' /* ' + type + ' */'
            else:
                assert type is not None
                t = mapping_fn(type[0])
                t += argname

            args.append(t)
        else:
            if is_array:
                if not is_forced_type and type == 'as':
                    conv = mapping_fn(type)
                else:
                    conv = mapping_fn('v')
            else:
                assert type is not None
                conv = mapping_fn(type[0])

            if use_plain_map_result:
                args.append(conv)
            elif conv:
                args.append(conv + '(' + argname + ')')
            else:
                args.append(argname)

    return args


def _format_string_list(args, indent=0, *,
                        leading_sep=None, leading_indent=True,
                        terminator=None):
    if not args:
        return ''

    spaces = ' ' * indent
    result = leading_sep if leading_sep else ''
    result += ('\n' + spaces) if leading_indent else ''

    if terminator:
        result += \
            (terminator + ('\n' if indent > 0 else ' ') + spaces).join(args)
        result += terminator
    else:
        result += (',' + ('\n' if indent > 0 else ' ') + spaces).join(args)

    return result


def _mk_initializer_list(params, is_method, *, need_return_types=False,
                         need_prefixed_names=True):
    statements = []

    for param in params.findall('arg'):
        if _skip_parameter(param, is_method, need_return_types):
            continue

        if need_prefixed_names:
            argname = 'out_' if need_return_types else 'arg_'
        else:
            argname = ''

        argname += param.attrib['name']

        if _type_is_gvariant(param):
            statements.append(argname + '_(std::move(g_variant_ref_sink(' +
                              argname + ')))')
        else:
            statements.append(argname + '_(std::move(' + argname + '))')

    return statements


def _mk_cleanup_statements(params, is_method, *, need_return_types,
                           need_prefixed_names=True):
    statements = []

    for param in params.findall('arg'):
        if _skip_parameter(param, is_method, need_return_types):
            continue

        if need_return_types and _type_is_pointer(param) and \
                not _type_is_string(param):
            if need_prefixed_names:
                argname = 'out_' + param.attrib['name']
            else:
                argname = param.attrib['name']

            if _type_is_string_array(param):
                statements.append(argname + '_.clear()')
            else:
                statements.append('if(' + argname + '_ != nullptr) '
                                  'g_variant_unref(' + argname + '_)')
                statements.append(argname + '_ = nullptr')
        elif not need_return_types and _type_is_gvariant(param):
            if need_prefixed_names:
                argname = 'arg_' + param.attrib['name']
            else:
                argname = param.attrib['name']

            statements.append('if(' + argname + '_ != nullptr) '
                              'g_variant_unref(' + argname + '_)')
            statements.append(argname + '_ = nullptr')

    return statements


def _mk_check_statements(params, is_method, *, need_return_types=False,
                         need_prefixed_names=True):
    statements = []

    for param in params.findall('arg'):
        if _skip_parameter(param, is_method, need_return_types):
            continue

        if need_prefixed_names:
            argname = 'out_' if need_return_types else 'arg_'
        else:
            argname = ''

        argname += param.attrib['name']

        if _type_is_pointer(param):
            if _type_is_string(param):
                statements.append(
                    'if(' + argname + '_.empty() && ' + argname +
                    ' != nullptr && ' + argname +
                    '[0] != \'\\0\') FAIL_CHECK("Argument ' + argname +
                    ' expected to be empty")')
                statements.append(
                    'else if(!' + argname + '_.empty()) CHECK(' +
                    argname + ' != nullptr)')
            elif _type_is_string_array(param):
                statements.append(
                    'if(' + argname + '_.empty() && ' + argname +
                    ' != nullptr && ' + argname +
                    '[0] != nullptr && ' + argname +
                    '[0][0] != \'\\0\') FAIL_CHECK("Argument ' + argname +
                    ' expected to be empty")')
                statements.append(
                    'else if(g_strv_length(const_cast<gchar **>(' + argname +
                    ')) != ' + argname +
                    '_.size()) CHECK(g_strv_length(const_cast<gchar **>(' +
                    argname + ')) == ' + argname + '_.size())')
                statements.append(
                    'else MockDBusUtils::expect_cstrings(' + argname + ', ' +
                    argname + '_)')
            else:
                statements.append(
                    'if(' + argname + '_ != nullptr) CHECK(' + argname +
                    ' != nullptr)')
                statements.append('else CHECK(' + argname + ' == nullptr)')

        use_default_checks = True

        for check_fn in param.findall('mock_check_fn'):
            conv = check_fn.attrib.get('type_conversion', None)

            if conv is None:
                conv = 'g_variant'

            if conv == 'g_variant':
                arg1 = 'const_cast<GVariant *>(' + argname + ')'
                arg2 = 'const_cast<GVariant *>(' + argname + '_)'
            elif conv == 'c++string':
                arg1 = 'std:string(' + argname + ')'
                arg2 = 'std:string(' + argname + '_)'
            elif conv == 'none':
                arg1 = argname
                arg2 = argname + '_'
            else:
                raise RuntimeError('Invalid conversion type "{}"'.format(conv))

            use_default_checks = False
            statements.append(
                'if(' + argname + ' != nullptr) ' + check_fn.attrib['name'] +
                '(' + arg1 + ', ' + arg2 + ')')

        if not use_default_checks:
            continue

        if _type_is_string(param):
            statements.append(
                'if(' + argname + ' != nullptr) CHECK(std::string(' +
                argname + ') == ' + argname + '_)')
            statements.append(
                'else CHECK(' + argname + '_.empty())')
        elif _type_is_float(param):
            statements.append('CHECK(' + argname + ' <= ' + argname + '_)')
            statements.append('CHECK(' + argname + ' >= ' + argname + '_)')
        elif not _type_is_string_array(param):
            statements.append('CHECK(' + argname + ' == ' + argname + '_)')

    return statements


def _mk_copy_statements(params, is_method, *, need_return_types=False,
                        need_prefixed_names=True):
    statements = []

    for param in params.findall('arg'):
        if _skip_parameter(param, is_method, need_return_types):
            continue

        if need_prefixed_names:
            argname = 'out_' if need_return_types else 'arg_'
        else:
            argname = ''

        argname += param.attrib['name']
        if _type_is_string(param):
            statements.append('*' + argname +
                              ' = g_strdup(' + argname + '_.c_str())')
        elif _type_is_string_array(param):
            statements.append('if(' + argname + ' != nullptr) *' + argname +
                              ' = MockDBusUtils::mk_cstring_array(' +
                              argname + '_)')
        elif _type_is_gvariant(param):
            statements.append('if(' + argname + ' != nullptr) *' + argname +
                              ' = g_variant_ref(' + argname + '_)')
        else:
            statements.append('if(' + argname + ' != nullptr) *' + argname +
                              ' = ' + argname + '_')

    return statements


def _gen_get_details_fn(code):
    if code is not None:
        return '\n    std::string get_details() const final override ' \
               '{{ {} }}'.format(code)
    else:
        return ""


def _write_method_call_expectation(hhfile, iface_name, iface_name_stripped,
                                   iface_type, method):
    template_call = """// Expecting async method call: {iface_name}.{class_name}
class {class_name}: public Expectation
{{""""""
  private:
    bool async_ready_ignored_;{}

  public:
    GCancellable *observed_cancellable_;
    GAsyncReadyCallback observed_async_ready_callback_;
    gpointer observed_user_data_;

    explicit {class_name}({}):
        Expectation("{class_name}"),
        async_ready_ignored_(false){}
    {{}}

    virtual ~{class_name}()
    {{
        if(observed_cancellable_ != nullptr)
            g_object_unref(observed_cancellable_);{}
    }}

    void check({iface_type} *proxy, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data{})
    {{
        CHECK(proxy == proxy_pointer(pp_offset_));
        if(cancellable != nullptr)
            g_object_ref(cancellable);
        observed_cancellable_ = cancellable;
        observed_async_ready_callback_ = callback;
        observed_user_data_ = user_data;{}

        if(async_ready_ignored_)
        {{
            CHECK(observed_async_ready_callback_ == nullptr);
            CHECK(observed_user_data_ == nullptr);
            CHECK(observed_cancellable_ == nullptr);
        }}
        else
        {{
            CHECK(observed_async_ready_callback_ != nullptr);
            CHECK(observed_cancellable_ != nullptr);
        }}
    }}

    static std::unique_ptr<{class_name}> make_from_check_parameters({iface_type} *, GCancellable *, GAsyncReadyCallback, gpointer{})
    {{
        return std::make_unique<{class_name}>({});
    }}

    void async_ready()
    {{
        REQUIRE(observed_async_ready_callback_ != nullptr);
        observed_async_ready_callback_(
                    reinterpret_cast<GObject *>(proxy_pointer(pp_offset_)),
                    async_result_pointer(), observed_user_data_);
    }}

    void async_ready_ignored()
    {{
        async_ready_ignored_ = true;
    }}

    {class_name} &set_proxy_index(unsigned long idx) {{ pp_offset_ = idx; return *this; }}
    {class_name} &set_invocation_index(unsigned long idx) {{ ip_offset_ = idx; return *this; }}{}
}};
"""
    class_name = method.attrib['name']
    members_async = _mk_argument_list(method, True,
                                      _map_simple_type_to_const_memtype,
                                      append_to_name='_')
    ctor_args = _mk_argument_list(method, True, _map_simple_type_to_ctortype)
    check_args = _mk_argument_list(method, True, _map_simple_type_to_ctype)
    ctor_init = _mk_initializer_list(method, True)
    ctor_init += [
        'observed_cancellable_(nullptr)',
        'observed_async_ready_callback_(nullptr)',
        'observed_user_data_(nullptr)',
    ]
    ctor_call_args = _mk_argument_list(method, True,
                                       _map_simple_type_to_conversion,
                                       need_types=False)
    cleanup_statements = \
        _mk_cleanup_statements(method, True, need_return_types=False)
    checks = _mk_check_statements(method, True)

    in_code = None
    out_code = None
    complete_code = None

    for details_code in method.findall('mock_details_code'):
        in_code = details_code.attrib.get('in_code', None)
        out_code = details_code.attrib.get('out_code', None)
        complete_code = details_code.attrib.get('complete_code', None)

        if any(c is not None for c in (in_code, out_code, complete_code)):
            break

    in_code_fn = _gen_get_details_fn(in_code)
    out_code_fn = _gen_get_details_fn(out_code)
    complete_code_fn = _gen_get_details_fn(complete_code)

    if in_code is not None and out_code is not None:
        sync_code_fn = \
            '\n    std::string get_details() const final override ' \
            '{{ return [this](){{ {} }}() + " ||=>|| " + ' \
            '[this](){{ {} }}(); }}' \
            .format(in_code, out_code)
    elif in_code is not None:
        sync_code_fn = in_code_fn
    elif out_code is not None:
        sync_code_fn = out_code_fn
    else:
        sync_code_fn = ""

    print(template_call.format(
            # class members
            _format_string_list(members_async, 4, terminator=';'),

            # ctor
            _format_string_list(ctor_args, 0, leading_indent=False),
            _format_string_list(ctor_init, 8, leading_sep=','),

            # dtor
            _format_string_list(cleanup_statements, 8, terminator=';'),

            # check()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(checks, 8, terminator=';'),

            # make_from_check_parameters()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(ctor_call_args, 0, leading_indent=False),

            # extra code
            in_code_fn,

            # assigned by keyword
            class_name=class_name,
            iface_type=iface_type,
            iface_name=iface_name),
          file=hhfile)

    template_finish = """// Expecting async method finish: {iface_name}.{method_name}
class {class_name}: public Expectation
{{
  private:
    GError *dbus_call_error_;{}

  public:
    GAsyncResult *observed_async_result_;

    explicit {class_name}({}):
        Expectation("{class_name}"){}
    {{}}

    virtual ~{class_name}()
    {{
        if(dbus_call_error_ != nullptr) g_error_free(dbus_call_error_);
        dbus_call_error_ = nullptr;{}
    }}

    gboolean check({iface_type} *proxy{}, GAsyncResult *res, GError **error)
    {{
        CHECK(proxy == proxy_pointer(pp_offset_));
        CHECK(res != nullptr);
        observed_async_result_ = res;

        if(dbus_call_error_ != nullptr)
        {{
            *error = dbus_call_error_;
            dbus_call_error_ = nullptr;
            return FALSE;
        }}
{}
        *error = nullptr;
        return TRUE;
    }}

    static std::unique_ptr<{class_name}> make_from_check_parameters({iface_type} *{}, GAsyncResult *, GError **)
    {{
        return std::make_unique<{class_name}>(nullptr{});
    }}

    {class_name} &set_proxy_index(unsigned long idx) {{ pp_offset_ = idx; return *this; }}
    {class_name} &set_invocation_index(unsigned long idx) {{ ip_offset_ = idx; return *this; }}{}
}};
"""
    method_name = method.attrib['name']
    class_name = method_name + 'Finish'
    members_finish = _mk_argument_list(method, True,
                                       _map_simple_type_to_memtype,
                                       need_return_types=True,
                                       append_to_name='_')
    ctor_args = ['GError *dbus_call_error']
    ctor_args += _mk_argument_list(method, True, _map_simple_type_to_ctortype,
                                   need_return_types=True)
    check_args = _mk_argument_list(method, True, _map_simple_type_to_cptrtype,
                                   need_return_types=True)
    ctor_init = ['dbus_call_error_(std::move(dbus_call_error))']
    ctor_init += _mk_initializer_list(method, True,
                                      need_return_types=True)
    ctor_init += ['observed_async_result_(nullptr)']
    ctor_call_args = _mk_argument_list(method, True,
                                       _map_simple_type_to_cpp_default_ctor,
                                       need_return_types=True,
                                       need_types=False,
                                       use_plain_map_result=True)
    cleanup_statements = \
        _mk_cleanup_statements(method, True, need_return_types=True)
    checks = _mk_copy_statements(method, True, need_return_types=True)
    print(template_finish.format(
            # class members
            _format_string_list(members_finish, 4, terminator=';'),

            # ctor
            _format_string_list(ctor_args, 0, leading_indent=False),
            _format_string_list(ctor_init, 8, leading_sep=','),

            # dtor
            _format_string_list(cleanup_statements, 8, terminator=';'),

            # check()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(checks, 8, terminator=';'),

            # make_from_check_parameters()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(ctor_call_args, 0, leading_sep=', ',
                                leading_indent=False),

            # extra code
            out_code_fn,

            # assigned by keyword
            method_name=method_name,
            class_name=class_name,
            iface_type=iface_type,
            iface_name=iface_name),
          file=hhfile)

    template_sync = """// Expecting sync method invocation: {iface_name}.{method_name}
class {class_name}: public Expectation
{{
  private:
    GError *dbus_call_error_;{}{}

  public:
    GCancellable *observed_cancellable_;

    explicit {class_name}({}):
        Expectation("{class_name}"){}
    {{}}

    virtual ~{class_name}()
    {{
        if(observed_cancellable_ != nullptr)
            g_object_unref(observed_cancellable_);
        if(dbus_call_error_ != nullptr) g_error_free(dbus_call_error_);
        dbus_call_error_ = nullptr;{}
    }}

    gboolean check({iface_type} *proxy{}, GCancellable *cancellable, GError **error)
    {{
        CHECK(proxy == proxy_pointer(pp_offset_));
        if(cancellable != nullptr)
            g_object_ref(cancellable);
        observed_cancellable_ = cancellable;

        if(dbus_call_error_ != nullptr)
        {{
            *error = dbus_call_error_;
            dbus_call_error_ = nullptr;
            return FALSE;
        }}
{}
        *error = nullptr;
        return TRUE;
    }}

    static std::unique_ptr<{class_name}> make_from_check_parameters({iface_type} *{}, GCancellable *, GError **)
    {{
        return std::make_unique<{class_name}>(nullptr{});
    }}

    {class_name} &set_proxy_index(unsigned long idx) {{ pp_offset_ = idx; return *this; }}
    {class_name} &set_invocation_index(unsigned long idx) {{ ip_offset_ = idx; return *this; }}{}
}};
"""
    method_name = method.attrib['name']
    class_name = method_name + 'Sync'
    ctor_args = ['GError *dbus_call_error']
    ctor_args += _mk_argument_list(method, True, _map_simple_type_to_ctortype)
    ctor_args += _mk_argument_list(method, True, _map_simple_type_to_ctortype,
                                   need_return_types=True)
    ctor_init = ['dbus_call_error_(std::move(dbus_call_error))']
    ctor_init += _mk_initializer_list(method, True)
    ctor_init += _mk_initializer_list(method, True, need_return_types=True)
    ctor_init += ['observed_cancellable_(nullptr)']
    ctor_call_args = _mk_argument_list(method, True,
                                       _map_simple_type_to_conversion,
                                       need_types=False)
    ctor_call_args += _mk_argument_list(method, True,
                                        _map_simple_type_to_cpp_default_ctor,
                                        need_return_types=True,
                                        need_types=False,
                                        use_plain_map_result=True)
    check_args = _mk_argument_list(method, True, _map_simple_type_to_ctype)
    check_args += _mk_argument_list(method, True, _map_simple_type_to_cptrtype,
                                    need_return_types=True)
    cleanup_statements = \
        _mk_cleanup_statements(method, True, need_return_types=False)
    cleanup_statements += \
        _mk_cleanup_statements(method, True, need_return_types=True)
    checks = _mk_check_statements(method, True)
    checks += _mk_copy_statements(method, True, need_return_types=True)
    print(template_sync.format(
            # class members
            _format_string_list(members_async, 4, terminator=';'),
            _format_string_list(members_finish, 4, terminator=';'),

            # ctor
            _format_string_list(ctor_args, 0, leading_indent=False),
            _format_string_list(ctor_init, 8, leading_sep=','),

            # dtor
            _format_string_list(cleanup_statements, 8, terminator=';'),

            # check()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(checks, 8, terminator=';'),

            # make_from_check_parameters()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(ctor_call_args, 0,
                                leading_sep=', ', leading_indent=False),

            # extra code
            sync_code_fn,

            # assigned by keyword
            method_name=method_name,
            class_name=class_name,
            iface_type=iface_type,
            iface_name=iface_name),
          file=hhfile)

    template_complete = """// Expecting async method completion: {iface_name}.{method_name}
class {class_name}: public Expectation
{{
  private:{}

  public:
    explicit {class_name}({}):
        Expectation("{class_name}"){}
    {{}}

    virtual ~{class_name}()
    {{""""""{}
    }}

    void check({iface_type} *object, GDBusMethodInvocation *invocation{})
    {{
        CHECK(object == proxy_pointer(pp_offset_));
        CHECK(invocation == invocation_pointer(ip_offset_));{}
    }}

    static std::unique_ptr<{class_name}> make_from_check_parameters({iface_type} *, GDBusMethodInvocation *{})
    {{
        return std::make_unique<{class_name}>({});
    }}
{}
}};
"""
    method_name = method.attrib['name']
    class_name = method_name + 'Complete'
    members_complete = _mk_argument_list(method, True,
                                         _map_simple_type_to_memtype,
                                         need_return_types=True,
                                         append_to_name='_',
                                         need_prefixed_names=False)
    ctor_args = _mk_argument_list(method, True, _map_simple_type_to_ctortype,
                                  need_return_types=True,
                                  need_prefixed_names=False)
    ctor_init = _mk_initializer_list(method, True, need_return_types=True,
                                     need_prefixed_names=False)
    ctor_call_args = _mk_argument_list(method, True,
                                       _map_simple_type_to_conversion,
                                       need_return_types=True,
                                       need_prefixed_names=False,
                                       need_types=False)
    cleanup_statements = \
        _mk_cleanup_statements(method, True, need_return_types=True,
                               need_prefixed_names=False)
    check_args = _mk_argument_list(method, True, _map_simple_type_to_ctype,
                                   need_return_types=True,
                                   need_prefixed_names=False)
    checks = _mk_check_statements(method, True, need_return_types=True,
                                  need_prefixed_names=False)
    print(template_complete.format(
            # class members
            _format_string_list(members_complete, 4, terminator=';'),

            # ctor
            _format_string_list(ctor_args, 0, leading_indent=False),
            _format_string_list(ctor_init, 8, leading_sep=','),

            # dtor
            _format_string_list(cleanup_statements, 8, terminator=';'),

            # check()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(checks, 8, terminator=';'),

            # make_from_check_parameters()
            _format_string_list(check_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(ctor_call_args, 0, leading_indent=False),

            # extra code
            complete_code_fn,

            # assigned by keyword
            method_name=method_name,
            class_name=class_name,
            iface_type=iface_type,
            iface_name=iface_name),
          file=hhfile)


def _write_signal_emit_expectation(hhfile, iface_name, iface_name_stripped,
                                   iface_type, signal):
    template = """// Base class for signal emission: {iface_name}.{class_name}
class {class_name}Base: public Expectation
{{
  public:
    explicit {class_name}Base(std::string &&name):
       Expectation(std::move(name))
    {{}}

    virtual void check({check_params}) = 0;

    static std::unique_ptr<{class_name}Base> make_from_check_parameters({check_params});

    {class_name}Base &set_proxy_index(unsigned long idx) {{ pp_offset_ = idx; return *this; }}
    {class_name}Base &set_invocation_index(unsigned long idx) {{ ip_offset_ = idx; return *this; }}
}};

// Expecting signal emission: {iface_name}.{class_name}
class {class_name}: public {class_name}Base
{{""""""
  private:{}

  public:
    explicit {class_name}({}):
        {class_name}Base("{class_name}"){}
    {{}}

    void check({check_params}) override
    {{
        CHECK(object == proxy_pointer(pp_offset_));{}
    }}
{}
}};

// Expecting signal emission: {iface_name}.{class_name}
class {class_name_ext}: public {class_name}Base
{{
  private:
    std::function<void({iface_type} *object{})> check_full_fn_;
    std::function<void()> check_simple_fn_;

  public:
    explicit {class_name_ext}(std::nullptr_t):
        {class_name}Base("{class_name_ext} (ignored)")
    {{}}

    explicit {class_name_ext}(std::function<void({iface_type} *object{})> &&check_full_fn):
        {class_name}Base("{class_name_ext} (full)"),
        check_full_fn_(std::move(check_full_fn))
    {{}}

    explicit {class_name_ext}(std::function<void()> &&check_simple_fn):
        {class_name}Base("{class_name_ext} (simple)"),
        check_simple_fn_(std::move(check_simple_fn))
    {{}}

    void check({check_params}) override
    {{
        CHECK(object == proxy_pointer(pp_offset_));
        if(check_simple_fn_ != nullptr)
            check_simple_fn_();
        if(check_full_fn_ != nullptr)
            check_full_fn_(object{});
    }}

    {class_name_ext} &set_proxy_index(unsigned long idx) {{ pp_offset_ = idx; return *this; }}
    {class_name_ext} &set_invocation_index(unsigned long idx) {{ ip_offset_ = idx; return *this; }}
}};
"""
    class_name = signal.attrib['name']
    members = _mk_argument_list(signal, False,
                                _map_simple_type_to_const_memtype,
                                append_to_name='_')
    ctor_args = _mk_argument_list(signal, False, _map_simple_type_to_ctortype)
    check_args = _mk_argument_list(signal, False, _map_simple_type_to_ctype)
    check_ext_args = _mk_argument_list(signal, False, _map_simple_type_to_ctortype)
    ctor_init = _mk_initializer_list(signal, False)
    ctor_call_args = _mk_argument_list(signal, False,
                                       _map_simple_type_to_conversion,
                                       need_types=False)
    checks = _mk_check_statements(signal, False)

    code = None
    for details_code in signal.findall('mock_details_code'):
        code = details_code.attrib.get('code', None)
        if code is not None:
            break
    code = _gen_get_details_fn(code)

    print(template.format(
            # class members of automatically checked expectation
            _format_string_list(members, 4, terminator=';'),

            # ctor
            _format_string_list(ctor_args, 0, leading_indent=False),
            _format_string_list(ctor_init, 8, leading_sep=','),

            # check()
            _format_string_list(checks, 8, terminator=';'),

            # extra code
            code,


            # class members of manually checked expectation
            _format_string_list(check_ext_args, 0,
                                leading_sep=', ', leading_indent=False),

            # ctors
            _format_string_list(check_ext_args, 0,
                                leading_sep=', ', leading_indent=False),

            # check()
            _format_string_list(ctor_call_args, 0,
                                leading_sep=', ', leading_indent=False),

            # assigned by keyword
            class_name=class_name,
            class_name_ext=class_name + "WithExtCheck",
            iface_type=iface_type,
            iface_name=iface_name,
            check_params=iface_type + ' *object' + _format_string_list(
                check_args, 0, leading_sep=', ', leading_indent=False)),
          file=hhfile)


def _write_header_body(hhfile, iface_prefix, c_namespace, cpp_namespace,
                       dummy_pointer_value, iface):
    template = """
static constexpr unsigned long PROXY_POINTER_PATTERN = {};
static constexpr unsigned long IFACE_POINTER_PATTERN = PROXY_POINTER_PATTERN;
static constexpr unsigned long ASYNC_RESULT_PATTERN = {};
static constexpr unsigned long METHOD_INVOCATION_PATTERN = {};

static inline auto *proxy_pointer(unsigned long offset = 0)
{{
    return reinterpret_cast<{iface_type} *>(PROXY_POINTER_PATTERN + offset);
}}

static inline GAsyncResult *async_result_pointer(unsigned long offset = 0)
{{
    return reinterpret_cast<GAsyncResult *>(ASYNC_RESULT_PATTERN + offset);
}}

static inline GDBusMethodInvocation *invocation_pointer(unsigned long offset = 0)
{{
    return reinterpret_cast<GDBusMethodInvocation *>(METHOD_INVOCATION_PATTERN + offset);
}}

static inline std::unique_ptr<TDBus::Proxy<{iface_type}>>
make_unique_proxy(
        std::string &&name = "{dbus_name}",
        std::string &&path = "{dbus_path}",
        unsigned long offset = 0)
{{
    return std::make_unique<TDBus::Proxy<{iface_type}>>(TDBus::Proxy<{iface_type}>::make_proxy_for_testing(
            std::move(name), std::move(path),
            PROXY_POINTER_PATTERN + offset));
}}

static inline TDBus::Iface<{iface_type}> &get_exported_dummy_iface()
{{
    using IfaceType = {iface_type};
    struct Traits {{ static IfaceType *skeleton_new() {{ return reinterpret_cast<IfaceType *>(IFACE_POINTER_PATTERN); }} }};
    static TDBus::Iface<IfaceType, Traits> iface("{dbus_path}", true);
    return reinterpret_cast<TDBus::Iface<IfaceType> &>(iface);
}}

/*! Base class for {cpp_namespace} expectations. */
class Expectation: public MockExpectationBase
{{
  protected:
    unsigned long pp_offset_;
    unsigned long ip_offset_;

  public:
    Expectation(std::string &&name):
        MockExpectationBase(std::move(name)),
        pp_offset_(0),
        ip_offset_(0)
    {{}}

    virtual ~Expectation() {{}}
}};


/*! Base class for {cpp_namespace} expectations with external check function. */
class ExpectationWithExtCheck: public Expectation
{{
  public:
    ExpectationWithExtCheck(std::string &&name):
        Expectation(std::move(name))
    {{}}

    virtual ~ExpectationWithExtCheck() {{}}
}};

/*! Mock for {cpp_namespace} expectations */
class Mock: public MockBase
{{
  public:
    Mock(const Mock &) = delete;
    Mock &operator=(const Mock &) = delete;

    explicit Mock(std::shared_ptr<MockExpectationSequence> eseq = nullptr):
        MockBase("{cpp_namespace}", eseq)
    {{}}

    virtual ~Mock() {{}}

    void expect(std::unique_ptr<Expectation> expectation)
    {{
        add(std::move(expectation));
    }}

    void expect(Expectation *expectation)
    {{
        add(std::unique_ptr<Expectation>(expectation));
    }}

    template <typename T, typename ... Args>
    auto &expect(Args ... args)
    {{
        static_assert(std::is_base_of_v<Expectation, T> == true);
        return *static_cast<T *>(add(std::make_unique<T>(std::forward<Args>(args)...)));
    }}

    template <typename T>
    void ignore(std::unique_ptr<Expectation> default_result)
    {{
        static_assert(std::is_base_of_v<Expectation, T> == true);
        MockBase::ignore<T>(std::move(default_result));
    }}

    template <typename T>
    void ignore(Expectation *default_result)
    {{
        static_assert(std::is_base_of_v<Expectation, T> == true);
        MockBase::ignore<T>(std::unique_ptr<Expectation>(default_result));
    }}
}};

"""
    iface_name = iface.attrib['name']
    iface_name_stripped = _remove_prefix(iface_name, iface_prefix)
    iface_type = c_namespace.replace('_', '') + iface_name_stripped
    dbus_name = 'unittests.up.' + iface_name
    dbus_path = dbus_name.replace('.', '/')
    print(template.format(dummy_pointer_value,
                          hex(int(dummy_pointer_value, 0) + 1),
                          hex(int(dummy_pointer_value, 0) + 2),

                          # assigned by keyword
                          dbus_name=dbus_name,
                          dbus_path=dbus_path,
                          iface_type=iface_type,
                          iface_name=iface_name,
                          cpp_namespace=cpp_namespace),
          file=hhfile)

    for method in iface.findall('method'):
        _write_method_call_expectation(hhfile, iface_name, iface_name_stripped,
                                       iface_type, method)

    for signal in iface.findall('signal'):
        _write_signal_emit_expectation(hhfile, iface_name, iface_name_stripped,
                                       iface_type, signal)


def _write_impl_top(ccfile, mock_header_name):
    template = """//
// Generated by taddybus-mockgen.
// Do not modify!
//

#if HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "{}"
"""
    print(template.format(mock_header_name), file=ccfile)


def _mk_call_parameter_list(params, is_method, *, need_return_types=False,
                            need_prefixed_names=True):
    names = []

    for param in params.findall('arg'):
        if _skip_parameter(param, is_method, need_return_types):
            continue

        if need_prefixed_names:
            argname = 'out_' if need_return_types else 'arg_'
        else:
            argname = ''

        argname += param.attrib['name']
        names.append(argname)

    return names


def _write_method_call_mocks(ccfile, iface_name, iface_type, cpp_namespace,
                             fn_prefix, method):
    template = """
// Mock functions for method call: {iface_name}.{method_name}
void {}({iface_type} *proxy{}, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data)
{{
    REQUIRE({cpp_namespace}::singleton != nullptr);
    {cpp_namespace}::singleton->check_next<{cpp_namespace}::{method_name}>(proxy, cancellable, callback, user_data{});
}}

gboolean {}({iface_type} *proxy{}, GAsyncResult *res, GError **error)
{{
    REQUIRE({cpp_namespace}::singleton != nullptr);
    CHECK(res == {cpp_namespace}::async_result_pointer());
    return {cpp_namespace}::singleton->check_next<{cpp_namespace}::{method_name}Finish>(proxy{}, res, error);
}}

gboolean {}({iface_type} *proxy{}{}, GCancellable *cancellable, GError **error)
{{
    REQUIRE({cpp_namespace}::singleton != nullptr);
    return {cpp_namespace}::singleton->check_next<{cpp_namespace}::{method_name}Sync>(proxy{}{}, cancellable, error);
}}

void {}({iface_type} *object, GDBusMethodInvocation *invocation{})
{{
    REQUIRE({cpp_namespace}::singleton != nullptr);
    REQUIRE(object != nullptr);
    return {cpp_namespace}::singleton->check_next<{cpp_namespace}::{method_name}Complete>(object, invocation{});
}}
"""
    method_name = method.attrib['name']
    call_fn_args = _mk_argument_list(method, True, _map_simple_type_to_ctype)
    call_forward_args = _mk_call_parameter_list(method, True)
    finish_fn_args = _mk_argument_list(method, True,
                                       _map_simple_type_to_cptrtype,
                                       need_return_types=True)
    finish_forward_args = _mk_call_parameter_list(method, True,
                                                  need_return_types=True)
    complete_fn_args = _mk_argument_list(method, True,
                                         _map_simple_type_to_ctype,
                                         need_return_types=True,
                                         need_prefixed_names=False)
    complete_forward_args = _mk_call_parameter_list(method, True,
                                                    need_return_types=True,
                                                    need_prefixed_names=False)
    print(template.format(
            # call_...()
            _method_name(fn_prefix,
                         'call_' + _to_snake_case(method.attrib['name'])),
            _format_string_list(call_fn_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(call_forward_args, 0,
                                leading_sep=', ', leading_indent=False),

            # call_..._finish()
            _method_name(fn_prefix,
                         'call_' + _to_snake_case(method.attrib['name']) +
                         '_finish'),
            _format_string_list(finish_fn_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(finish_forward_args, 0,
                                leading_sep=', ', leading_indent=False),

            # call_..._sync()
            _method_name(fn_prefix,
                         'call_' + _to_snake_case(method.attrib['name']) +
                         '_sync'),
            _format_string_list(call_fn_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(finish_fn_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(call_forward_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(finish_forward_args, 0,
                                leading_sep=', ', leading_indent=False),

            # complete_...()
            _method_name(fn_prefix,
                         'complete_' + _to_snake_case(method.attrib['name'])),
            _format_string_list(complete_fn_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(complete_forward_args, 0,
                                leading_sep=', ', leading_indent=False),

            # assigned by keyword
            method_name=method_name,
            iface_type=iface_type,
            iface_name=iface_name,
            cpp_namespace=cpp_namespace),
          file=ccfile)


def _write_signal_emit_mocks(ccfile, iface_name, iface_type, cpp_namespace,
                             fn_prefix, signal):
    template = """
// Mock function for signal: {iface_name}.{signal_name}
void {}({iface_type} *object{})
{{
    REQUIRE({cpp_namespace}::singleton != nullptr);
    REQUIRE(object != nullptr);
    return {cpp_namespace}::singleton->check_next<{cpp_namespace}::{signal_name}Base>(object{});
}}

std::unique_ptr<{cpp_namespace}::{class_name}Base> {cpp_namespace}::{class_name}Base::make_from_check_parameters({})
{{
    return std::make_unique<{class_name}>({});
}}"""
    class_name = signal.attrib['name']
    call_fn_args = _mk_argument_list(signal, False, _map_simple_type_to_ctype)
    call_forward_args = _mk_call_parameter_list(signal, False)
    check_args = _mk_argument_list(signal, False, _map_simple_type_to_ctype)
    ctor_call_args = _mk_argument_list(signal, False,
                                       _map_simple_type_to_conversion,
                                       need_types=False)

    print(template.format(
            # mock function
            _method_name(fn_prefix,
                         'emit_' + _to_snake_case(signal.attrib['name'])),
            _format_string_list(call_fn_args, 0,
                                leading_sep=', ', leading_indent=False),
            _format_string_list(call_forward_args, 0,
                                leading_sep=', ', leading_indent=False),

            # make_from_check_parameters()
            iface_type + ' *object' + _format_string_list(
                check_args, 0, leading_sep=', ', leading_indent=False),
            _format_string_list(ctor_call_args, 0, leading_indent=False),

            # assigned by keyword
            class_name=class_name,
            signal_name=signal.attrib['name'],
            iface_type=iface_type,
            iface_name=iface_name,
            cpp_namespace=cpp_namespace),
          file=ccfile)


def _write_impl_body(ccfile, iface_prefix, c_namespace, cpp_namespace, iface):
    template = """template <>
TDBus::Proxy<{iface_type}> &TDBus::get_singleton()
{{
    static auto proxy(TDBus::Proxy<{iface_type}>::make_proxy_for_testing(
            "{dbus_name}",
            "{dbus_path}",
            {cpp_namespace}::PROXY_POINTER_PATTERN));
    return proxy;
}}

{cpp_namespace}::Mock *{cpp_namespace}::singleton = nullptr;"""
    iface_name = iface.attrib['name']
    iface_name_stripped = _remove_prefix(iface_name, iface_prefix)
    iface_type = c_namespace.replace('_', '') + iface_name_stripped
    dbus_name = 'unittests.' + iface_name
    print(template.format(dbus_name=dbus_name,
                          dbus_path='/' + dbus_name.replace('.', '/'),
                          iface_type=iface_type,
                          cpp_namespace=cpp_namespace),
          file=ccfile)

    fn_prefix = c_namespace + '_' + _to_snake_case(iface_name_stripped)
    for method in iface.findall('method'):
        _write_method_call_mocks(ccfile, iface_name, iface_type, cpp_namespace,
                                 fn_prefix, method)
    for signal in iface.findall('signal'):
        _write_signal_emit_mocks(ccfile, iface_name, iface_type, cpp_namespace,
                                 fn_prefix, signal)


def main():
    parser = argparse.ArgumentParser(
        description='Generate C++ headers from D-Bus introspection data')
    parser.add_argument(
        '--interface', metavar='NAME', type=str, required=True,
        help='the D-Bus interface to generate the mock for')
    parser.add_argument(
        '--interface-prefix', metavar='PREFIX', type=str,
        help='string to strip from D-Bus interface names')
    parser.add_argument(
        '--c-namespace', metavar='NAMESPACE', type=str,
        help='the namespace used by the C code generated by gdbus-codegen')
    parser.add_argument(
        '--cpp-namespace', metavar='NAMESPACE', type=str, required=True,
        help='the namespace used by the generated mock')
    parser.add_argument(
        '--pointer-pattern', metavar='PREFIX', type=str, required=True,
        help='recognizable dummy value to use for D-Bus proxy pointers')
    parser.add_argument(
        '--output-hh', '-o', metavar='FILE', type=Path,
        help='write C++ header to this file instead of stdout')
    parser.add_argument(
        '--output-cc', '-O', metavar='FILE', type=Path,
        help='write C++ implementation to this file instead of stdout')
    parser.add_argument(
        '--include-guard', metavar='NAME', type=str,
        help='name of the #include guard written to the header file')
    parser.add_argument(
        'FILE', type=Path,
        help='XML file containing the D-Bus interface specification')
    args = parser.parse_args()
    options = vars(args)

    xmlfile = ET.parse(options['FILE'].open())
    interface_spec = xmlfile.findall('./interface[@name=\'' +
                                     options['interface'] + '\']')
    if len(interface_spec) == 1:
        interface_spec = interface_spec[0]
    else:
        print('Interface "{}" {} in {}'.format(
            options['interface'],
            'not found' if len(interface_spec) == 0 else 'is ambiguous',
            options['FILE']))
        sys.exit(10)

    hhfile = options['output_hh'].open('w') \
        if options['output_hh'] else sys.stdout
    ccfile = options['output_cc'].open('w') \
        if options['output_cc'] else sys.stdout

    include_guard = _mk_include_guard(options)
    mocked_header = options['FILE'].stem + '.hh'

    _write_header_top(hhfile, include_guard, mocked_header,
                      options['cpp_namespace'])
    _write_header_body(
        hhfile, options['interface_prefix'], options['c_namespace'],
        options['cpp_namespace'], options['pointer_pattern'], interface_spec)
    _write_header_bottom(hhfile, include_guard)

    mock_header_name = options['output_hh'].name \
        if options['output_hh'] else ''
    _write_impl_top(ccfile, mock_header_name)
    _write_impl_body(
        ccfile, options['interface_prefix'], options['c_namespace'],
        options['cpp_namespace'], interface_spec)


if __name__ == '__main__':
    main()

#! /usr/bin/env python3

#
# Copyright (C) 2022  T+A elektroakustik GmbH & Co. KG
#
# This file is part of T+A-D-Bus.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#

import argparse
import xml.etree.ElementTree as ET
from pathlib import Path
import sys
import re


def _mk_include_guard(options):
    if options['include_guard']:
        return options['include_guard']

    if options['output']:
        return options['output'].name.upper().replace('.', '_')

    return options['FILE'].stem.upper() + '_HH'


def _write_header_top(hhfile, include_guard, gdbus_header, namespace):
    template = """//
// Generated by taddybus-codegen.
// Do not modify!
//

#ifndef {}
#define {}

#include "dbus/{}"
#include "dbus/taddybus.hh"

namespace {}
{{"""
    print(template.format(include_guard, include_guard, gdbus_header,
                          namespace),
          file=hhfile)


def _write_header_bottom(hhfile, include_guard):
    template = """}}

#endif /* !{} */"""
    print(template.format(include_guard), file=hhfile)


def _to_snake_case(name, divider='_'):
    return divider.join(re.findall(R'[A-Z]+$|[A-Z]*[a-z]+', name)).lower()


def _method_name(iface_type, name, is_call=False):
    return _to_snake_case(iface_type) + '_' + name + ('()' if is_call else '')


def _simple_type_to_ctype(typespec):
    dbus_type_to_ctype = {
        "b": "gboolean",
        "d": "gdouble",
        "i": "gint",
        "n": "gint16",
        "o": "const gchar *",
        "q": "guint16",
        "s": "const gchar *",
        "t": "guint64",
        "u": "guint",
        "v": "GVariant *",
        "x": "gint64",
        "y": "guchar"
    }

    ctype = dbus_type_to_ctype.get(typespec, None)
    if ctype and ctype[-1] != '*':
        return ctype + ' '
    else:
        return ctype


def _mk_c_argument_list(params, is_method):
    args = []

    for param in params.findall('arg'):
        if is_method:
            dir = param.attrib.get('direction', 'in')
            if dir != 'in':
                continue

        argname = 'arg_' + param.attrib['name']
        type = None

        for anno in param.findall('annotation'):
            if anno.attrib['name'] == 'org.gtk.GDBus.C.ForceGVariant' and \
                    anno.attrib['value'] == 'arg':
                type = param.attrib['type']
                is_array = True
                break

        if not type:
            type = param.attrib['type']
            is_array = type[0] == 'a'

        if is_array:
            t = _simple_type_to_ctype('v') + argname + ' /* ' + type + ' */'
        else:
            t = _simple_type_to_ctype(type[0])
            t += argname

        args.append(t)

    return args


def _format_argument_list(args, indent):
    if not args:
        return ''

    spaces = ' ' * indent
    return '\n' + spaces + (',\n' + spaces).join(args) + ','


def _write_method_code(hhfile, iface_name, iface_name_stripped, iface_type,
                       traits_prefix, fn_prefix, method):
    handler_template = """// Method {}.{}
struct {};

template <>
struct MethodHandlerTraits<{}>
{{
  private:
    using ThisMethod = {};

  public:
    using IfaceType = {};

    static const char *glib_signal_name() {{ return "handle-{}"; }}

    template <typename... UserDataT>
    using UserData = Iface<IfaceType>::MethodHandlerData<ThisMethod, UserDataT...>;

    template <typename... UserDataT>
    using HandlerType =
        gboolean(IfaceType *const object,
                 GDBusMethodInvocation *const invocation,{}
                 UserData<UserDataT...> *const d);

    /*!
     * Handler for this D-Bus method.
     *
     * Must be implemented by application if it wants to handle this method.
     * The handler is connected by calling D-Bus interface function
     * #TDBus::Iface::connect_default_method_handler().
     */
    static gboolean method_handler(
            IfaceType *const object, GDBusMethodInvocation *const invocation,{}
            Iface<IfaceType> *const iface);

    static constexpr auto complete = {};
}};
"""
    method_type = traits_prefix + iface_name_stripped + method.attrib['name']
    args = _mk_c_argument_list(method, True)
    complete_fn_name = \
        _method_name(fn_prefix,
                     'complete_' + _to_snake_case(method.attrib['name']))
    print(handler_template.format(iface_name, method.attrib['name'],
                                  method_type, method_type, method_type,
                                  iface_type,
                                  _to_snake_case(method.attrib['name'], '-'),
                                  _format_argument_list(args, 17),
                                  _format_argument_list(args, 12),
                                  complete_fn_name),
          file=hhfile)

    caller_template = """template <>
struct MethodCallerTraits<{}>
{{
    using IfaceType = {};
    static constexpr auto invoke = {};
    static constexpr auto finish = {};
}};
"""
    invoke_fn_name = \
        _method_name(fn_prefix,
                     'call_' + _to_snake_case(method.attrib['name']))
    finish_fn_name = \
        _method_name(fn_prefix,
                     'call_' + _to_snake_case(method.attrib['name']) +
                     '_finish')
    print(caller_template.format(method_type, iface_type,
                                 invoke_fn_name, finish_fn_name),
          file=hhfile)


def _write_signal_code(hhfile, iface_name, iface_name_stripped, iface_type,
                       traits_prefix, signal):
    template = """// Signal {}.{}
struct {};

template <>
struct SignalHandlerTraits<{}>
{{
  private:
    using ThisSignal = {};

  public:
    using IfaceType = {};

    static const char *glib_signal_name() {{ return "{}"; }}

    template <typename... UserDataT>
    using UserData = Proxy<IfaceType>::SignalHandlerData<ThisSignal, UserDataT...>;

    template <typename... UserDataT>
    using HandlerType =
        void(IfaceType *const object,{}
             UserData<UserDataT...> *const d);

    /*!
     * Handler for this D-Bus signal.
     *
     * Must be implemented by application if it wants to handle this signal.
     * The handler is connected by calling proxy function
     * #TDBus::Proxy::connect_default_signal_handler().
     */
    static void signal_handler(
            IfaceType *const object,{}
            Proxy<IfaceType> *const proxy);
}};
"""
    signal_type = traits_prefix + iface_name_stripped + signal.attrib['name']
    args = _mk_c_argument_list(signal, False)
    print(template.format(iface_name, signal.attrib['name'],
                          signal_type, signal_type, signal_type,
                          iface_type,
                          _to_snake_case(signal.attrib['name'], '-'),
                          _format_argument_list(args, 13),
                          _format_argument_list(args, 12)),
          file=hhfile)


if sys.version_info >= (3, 9, 0):
    def _remove_prefix(s, p):
        return s.removeprefix(p)
else:
    def _remove_prefix(s, p):
        return s[len(p):] if s.startswith(p) else s


def _write_interface_code(hhfile, iface, iface_prefix, method_traits_prefix,
                          signal_traits_prefix, c_namespace):
    template = """
//
// D-Bus interface: {}
//
template <>
struct IfaceTraits<{}>
{{
    static {} *skeleton_new() {{ return {}; }}
}};

template <>
struct ProxyTraits<{}>
{{
    static ProxyBase::ProxyNewFunction
    proxy_new_fn() {{ return {}; }}

    static ProxyBase::ProxyNewFinishFunction<{}>
    proxy_new_finish_fn() {{ return {}; }}
}};
"""
    iface_name = iface.attrib['name']
    iface_name_stripped = _remove_prefix(iface_name, iface_prefix)
    iface_type = c_namespace.replace('_', '') + iface_name_stripped
    fn_prefix = c_namespace + '_' + _to_snake_case(iface_name_stripped)
    print(template.format(iface_name, iface_type, iface_type,
                          _method_name(fn_prefix, 'skeleton_new', True),
                          iface_type, _method_name(fn_prefix, 'proxy_new'),
                          iface_type,
                          _method_name(fn_prefix, 'proxy_new_finish')),
          file=hhfile)

    for method in iface.findall('method'):
        _write_method_code(hhfile, iface_name, iface_name_stripped,
                           iface_type, method_traits_prefix, fn_prefix, method)

    for signal in iface.findall('signal'):
        _write_signal_code(hhfile, iface_name, iface_name_stripped,
                           iface_type, signal_traits_prefix, signal)


def _write_body(hhfile, spec, iface_prefix, method_traits_prefix,
                signal_traits_prefix, c_namespace):
    for iface in spec.findall('interface'):
        _write_interface_code(hhfile, iface, iface_prefix,
                              method_traits_prefix, signal_traits_prefix,
                              c_namespace)


def main():
    parser = argparse.ArgumentParser(
        description='Generate C++ headers from D-Bus introspection data')
    parser.add_argument(
        '--interface-prefix', metavar='PREFIX', type=str,
        help='string to strip from D-Bus interface names')
    parser.add_argument(
        '--c-namespace', metavar='NAMESPACE', type=str,
        help='the namespace used by the C code generated by gdbus-codegen')
    parser.add_argument(
        '--cpp-namespace', metavar='NAMESPACE', type=str, default='TDBus',
        help='the namespace to use for the generated C++ header '
        '(default: TDBus)')
    parser.add_argument(
        '--cpp-traits-prefix', metavar='PREFIX', type=str, default='',
        help='string to add to generated C++ traits structure names '
        '(default: none)')
    parser.add_argument(
        '--cpp-traits-method-prefix', metavar='PREFIX', type=str, default='',
        help='string to add to generated C++ traits structure names for D-Bus '
        'methods (appended to prefix passed via --cpp-traits-prefix; '
        'default: none)')
    parser.add_argument(
        '--cpp-traits-signal-prefix', metavar='PREFIX', type=str, default='',
        help='string to add to generated C++ traits structure names for D-Bus '
        'signals (appended to prefix passed via --cpp-traits-prefix; '
        'default: none)')
    parser.add_argument(
        '--output', '-o', metavar='FILE', type=Path,
        help='write C++ header to this file instead of stdout')
    parser.add_argument(
        '--include-guard', metavar='NAME', type=str,
        help='name of the #include guard written to the header file')
    parser.add_argument(
        'FILE', type=Path,
        help='XML file containing the D-Bus interface specification')
    args = parser.parse_args()
    options = vars(args)

    xmlfile = ET.parse(options['FILE'].open())

    hhfile = options['output'].open('w') if options['output'] else sys.stdout
    include_guard = _mk_include_guard(options)
    gdbus_header = options['FILE'].stem + '.h'
    _write_header_top(hhfile, include_guard, gdbus_header,
                      options['cpp_namespace'])
    _write_body(
        hhfile, xmlfile, options['interface_prefix'],
        options['cpp_traits_prefix'] + options['cpp_traits_method_prefix'],
        options['cpp_traits_prefix'] + options['cpp_traits_signal_prefix'],
        options['c_namespace'])
    _write_header_bottom(hhfile, include_guard)


if __name__ == '__main__':
    main()
